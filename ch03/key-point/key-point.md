# 第3章要点

### 1. 正则表达式到 NFA、DFA 的转换



### 2. KMP 及其扩展算法(p87)

书中的讲解不是很透彻，可参考 matrix 的博文 [KMP算法详解](http://www.matrix67.com/blog/archives/115)。文中提供了例子，比较容易理解。

算法如下：

    j:=0;
    for i:=1 to n do
    begin
       while (j>0) and (B[j+1]<>A[i]) do j:=P[j];
       if B[j+1]=A[i] then j:=j+1;
       if j=m then
       begin
          writeln('Pattern occurs with shift ',i-m);
          j:=P[j];
       end;
    end;


需要注意的是，关于这个算法复杂度的解释，原文说到：“因此，整个过程中j最多加了n个1。于是，j最多只有n次减小的机会（j值减小的次数当然不能超过n，因为j永远是非负整数）。”

从前半句条件到后半句结论看起来不那么直接。可能会认为：有可能 j 在第 5 行先变大了， 然后又在第 4 行 变小了，依次交替，有可能超过 n 次。

其详细推导过程如下：

1. 首先每次 n 循环过程中，第 4 行和第 5 行的代码可能都执行，可能只有其中一行执行，也可能都不执行（ `(j=0) and (B[j+1]<>A[i])` 的情况）。以下推导中，我们忽略都不执行的情况，因为对结论没影响。

2. 然后第 5 行的第一次执行一定先于第 4 行的第一次执行（因为这样才能使得 j > 0）。

3. 当第 5 行第一次连续执行了 x（x>0） 次，在接下来一次 n 的循环中执行了第 4 行代码，此时 j 的初始值为 `x`。

4. 假定这次 while 实际循环了 y 次，也就是说 while 循环结束后，j 的最大值为 `x-y`，且 j >= 0 。

5. 当第 5 行再次连续执行了 x'（x'>=0） 次，然后在接下来一次 n 的循环中又执行了第 4 行代码，此时 j 的初始值最大为 `x-y+x'`。

6. 假定这次 while 实际循环了 y' 次，也就是说 while 循环完毕后，j 的最大值为 `x-y+x'-y'`，且 j >= 0。

7. 第 5 步和第 6 步 总是交替成对出现，使得每一次这样的情况出现后，j 的最大值为 `x-y+x'-y'+x''-y''+....`, 且 j >= 0。也就是说 `x+x'+x''+... >= y+y'+y''+...`，而 `x+x'+x''+...` 是第 5 行代码执行的总次数，最多为 n 次。`y+y'+y''+...` 是第 4 行代码循环的总次数，从前面的不等式看出来，这个循环的总次数不超过 n 次，也就是说 j 最多只有 n 次减少的机会。

### 3. 字符串处理算法的效率(p103)

对于每个构造得到的 DFA 状态，我们最多必须构造 4|r| 个新状态


### 4. DFA 模拟中的时间和空间的权衡(p116)

图 3-66 表示的算法